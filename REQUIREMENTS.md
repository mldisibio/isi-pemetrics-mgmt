# Requirements

This document describes the functional requirements and specifications for the PE_Metrics Dimension Management application.

## Overview

A simple (for internal use only) .NET 9.0 Windows Forms application for CRUD operations on PE_Metrics dimensions. "PE" refers to "Production Engineering" and reflects the context of software that tests water quality devices with sensors in a manufacturing environment. 

`PE_Metrics` is a star schema stored in MS Sql Server and consumed by Power BI. The dimensions ('Cell', 'PCStation', 'SoftwareTest', 'Product Number') each require manual maintenance which user currently does using raw sql, but it is tedious due to intentional foreign key constraints and the need to often check what already exists and then write cumbersome sql to insert new data or update existing rows.

This project is concerned only with the dimension table maintenence. The larger context is that fact table tracks the "Pass/Fail" outcome of each test run and this is used for manufacturing metrics such as "First Pass Yield" as broken down by each dimension.


## User Roles

Only the user and maybe one or two other experienced software developers will use the application to update the reference data as needed.

## Core Features

### Feature 1: Cell Maintenance

**Description**: 

- View all existing 'Cell' entries  (a physical production area associated to a specific product or closely related set of products) in a scrollable, non-paged data grid.
- Create a new Cell entry from a dedicated details dialog and display the autogenerated identity value immediately.
- Update existing Cells in the same or identical details dialog.

**User Stories**:
- As the data manager I want to view, create, or update entries in the `floor.Cell` dimension table.

**Acceptance Criteria**:
- [ ] All `floor.Cell` entries are displayed in a read-only, scrollable, non-paging tabular data grid.
- [ ] The grid can be sorted ascending or descending by each column header.
- [ ] The grid can be filtered by 'Active Only' where `ActiveTo` is null or greater than today inclusive.
- [ ] A new entry is added immediately from a dialog (not the grid) and the database autogenerated identity value is returned.
- [ ] An existing entry is selected from the read-only grid and updated using the same or identical dialog as insert.

**Business Rules**:
- A cell entry is never hard deleted, because a non-null `ActiveTo` date indicates the cell is no longer active, but remains for historical reporting.

---

### Feature 2: PCStation Maintenance

**Description**: 

A simple dialog to add new workstation name to `floor.PCStation` dimension table if it does not yet exist.

**User Stories**:
- As the data manager I want to provide a PC name, and receive confirmation if it already exists in the `floor.PCStation` dimension table or be given the option to add it.

**Acceptance Criteria**:
- [ ] If the PC name already exists, a confirmation is displayed and the option to add it is disabled.
- [ ] If the PC name does not exist, adding it requires an explicit action from the user.
- [ ] The ui component for accepting input will display existing matching entries on each keystroke sorted alphabetically.

**Business Rules**:
- A PC Name is unique and no surrogate Id is needed

---

### Feature 3: PC to Cell Mapping

**Description**: 

Allocate a PC workstation to one and only one Cell for a given time period. 

- View existing allocations in a read-only, scrollable, non-paging data grid. 
- Create a new allocation from a dedicated details dialog and display the autogenerated identity value immediately.
- Update existing allocations in the same or identical details dialog.
- Since the underlying table only requires a `CellId`, incorporate the actual cell name when viewing, creating, or modifying the entries.
    - Including extra attributes will require a new sql view as the source of the read-only data grid.

**User Stories**:
- As the data manager I want to view, create, or update entries in the `floor.CellByPCStation` mapping table.

**Acceptance Criteria**:
- [ ] All `floor.CellByPCStation` entries are displayed in a read-only, scrollable, non-paging tabular data grid.
- [ ] The grid can be sorted ascending or descending by each column header.
- [ ] The grid can be filtered by 'Active Only' where `ActiveTo` is null or greater than today inclusive.
- [ ] A new entry is added immediately from a dialog (not the grid) and the database autogenerated identity value is returned.
- [ ] An existing entry is selected from the read-only grid and updated using the same or identical dialog as insert.
- [ ] When creating a new entry, the CellId is chosen from a picker that displays all Cell names.
- [ ] When viewing the data grid, the CellName is displayed along with the CellId.

**Business Rules**:
- A PC-to-Cell entry is never hard deleted, because a non-null `ActiveTo` date indicates the PC is no longer assigned to the cell, but remains for historical reporting.

---

### Feature 4: Software Test (SwTest) Maintenance

**Description**: 

Maintain the list of software tests including obsolete tests or tests that are the same but vary by name and/or id.

- View existing software tests in a read-only, scrollable, non-paging data grid. 
- Create a new `sw.SwTestMap` entry from a dedicated details dialog and display the autogenerated identity value immediately.
- Update existing software tests in the same or identical details dialog.
- Assign the new software entry to one or more cells, or update existing cell assignments.
    - While this is a separate database table (`floor.CellBySwTest`), it is a simple join table of `CellId` and `SwTestMapId` and a separate management component is unnecessary.
    - However, the assignment should allow choosing from a list of all cells (e.g. a checkbox list) which should display the Cell Names.

**User Stories**:
- As the data manager I want to view, create, or update entries in the `sw.SwTestMap` dimension table.
- As the data manager I want to simultaneously maintain entries in the `floor.CellBySwTest` mapping table.

**Acceptance Criteria**:
- [ ] All `sw.SwTestMap` entries are displayed in a read-only, scrollable, non-paging tabular data grid.
- [ ] The grid can be sorted ascending or descending by each column header.
- [ ] The grid can be filtered by 'Active Only' where `LastRun` is null or within the past three months.
- [ ] A new entry is added immediately from a dialog (not the grid) and the database autogenerated identity value is returned.
- [ ] An existing entry is selected from the read-only grid and updated using the same or identical dialog as insert.
- [ ] Both new and existing entries allow for mapping to one or more cells as part of the create/update dialog.

**Business Rules**:
- A software test entry is never hard deleted, because the `LastRun` date suggests if a test is now obsolete, but remains for historical reporting.

---

### Feature 5: Part Number (TLA) Maintenance

**Description**: 

- View all existing 'TLA' entries (the ERP Part Number corresponding to the top level assembly) in a scrollable, non-paged data grid.
- Create a new TLA entry from a dedicated details dialog.
- Update existing Cells in the same or identical details dialog.
- Assign the new TLA entry to one or more cells, or update existing cell assignments.
    - While this is a separate database table (`floor.CellByPartNo`), it is a simple join table of `CellId` and `PartNo` and a separate management component is unnecessary.
    - However, the assignment should allow choosing from a list of all cells (e.g. a checkbox list) which should display the Cell Names.
- The data grid will also include a 'IsUsed' column which is true if `PartNo` is found in `activity.ProductionTest`.
    - Including extra attributes will require a new sql view as the source of the read-only data grid.
- Entries where 'IsUsed' is false will have an option for hard delete. This could be a button in the data grid that is disabled if 'IsUsed' is true.    

**User Stories**:
- As the data manager I want to view, create, or update entries in the `product.TLA` dimension table.
- As the data manager I want to simultaneously maintain entries in the `floor.CellByPartNo` mapping table.
- As the data manager I want to remove unnecessary entries from the `product.TLA` dimension table.

**Acceptance Criteria**:
- [ ] All `floor.TLA` entries are displayed in a read-only, scrollable, non-paging tabular data grid.
- [ ] The data grid will also include a 'IsUsed' column which is true if `PartNo` is found in `activity.ProductionTest`.
- [ ] The grid can be sorted ascending or descending by each column header.
- [ ] The grid can be filtered by a `contains` or `like` filter that searches case-insensitive across `Family`, `Subfamily`, `Formal Description` and `Description`
- [ ] The grid can be simultaneously filtered by the 'IsUsed' attribute.
- [ ] A new entry is added immediately from a dialog (not the grid).
- [ ] An existing entry is selected from the read-only grid and updated using the same or identical dialog as insert.

---

## UI/UX Requirements

- No business logic in UI event handlers.
- UI components may perform only superficial input checks (required fields, basic formatting).
- All business rule validation is enforced in the MS Sql Server `PE_Metrics` database via stored procedures and constraints.
- UI may only call application-layer commands or queries.
- The UI must remain responsive during command execution; database operations may be executed asynchronously, but success is not reported until SQL Server confirms the operation.


### Layout

- Layout requirements are flexible. 
- I imagine a modern layout with navigation where each feature is in its own tab or screen, and only one tab or screen is shown at a time.
- However as a desktop application that allows for state, the user should be able to navigate between screens without losing data.
- I envision the read-only grids to be the primary display on each tab.
    - When a user chooses to create or update, the dialog can either appear below the grid (grid display would be shortened and then return to full size when the new or updated record is submitted) or the dialog can pop up over the grid.    

### Grids/Lists

The total set of all dimensional data is small enough to be cached in memory for real-time navigation and filtering.

- Use Dependency Injection for the caching and application layer implementations
- The application uses an inline database (DuckDB preferred, SQLite acceptable) as a **read model cache**.
    - use `DuckDB.NET.Data.Full` nuget library for dotnet interaction with DuckDb
    - e.g. `dotnet add package DuckDB.NET.Data.Full`
- The cache is populated from SQL Server views on application startup.
- The cache is used **only for read operations** (queries, filtering, sorting, grid display).

### Command vs Query Responsibilities

- The UI issues **queries and commands** to the application layer.
- **Queries** read exclusively from the inline database cache (DuckDb).
    - use `DuckDB.NET.Data.Full` nuget library for dotnet interaction
    - e.g. `dotnet add package DuckDB.NET.Data.Full`
- **Commands** execute stored procedures directly against SQL Server (the system of record).
    - use plain ADO.Net classes for dotnet interaction
    - e.g. `using System.Data.SqlClient;`
- The inline cache must not accept writes originating from the UI.

### Cache Refresh Behavior

- After a successful command execution (create, update, delete):
  - The application layer triggers a refresh of the affected cached data from SQL Server.
- If a command fails:
  - The cache must not be modified.
  - The UI remains in its current state and displays the validation or error message.

## Error Handling & Validation

- Stored procedures enforce all business rules and may reject invalid operations.
- Business rule violations are communicated via SQL Server errors using custom error numbers.
- The application layer must translate database errors into user-friendly messages.
- Raw SQL error messages must not be displayed directly in the UI.
- The UI must preserve user-entered values when displaying validation errors.

---

## Technical Requirements

### Performance

Outside of the directive to use an inline database as a real-time cache, there are no special performance requirements.

### Security

- Preferred security model is to use Windows Authentication to communicate with Sql Server.
    - However, since it is only the cache/inline database that is communicating directly with Sql Server, a Sql Server logon can be used if needed (one already exists).
    - I suspect Windows Authentication is feasible because the cache will be in-process, not distributed. 
    - (If the cache were distributed, it might use a Sql Server logon or service account.)

### Data Persistence

- Inserts and updates are to be executed one record at a time immediately upon the user submitting.
- No batch update features are needed.
- Any cache data must be updated immediately and any UI data grids refreshed immediately.

## Transaction Boundaries

- Each create, update, or delete operation must be implemented as a single stored procedure call.
- Each stored procedure represents one atomic transaction.
- Transactions must not span multiple stored procedure calls.
- The UI and application layers must not manage database transactions.

---

## Future Considerations

- Design the application is such a way that the same business logic can be used later by a parallel version of the application that is a pure 'Terminal UI'
- Imagine that I am using the caching architectural design as a proof of concept for another desktop application that does metric reporting against a local inline database filled only once on startup.
